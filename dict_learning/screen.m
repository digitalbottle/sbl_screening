% THT algorithmfunction [vec,lambda_max] = screen(B,y,lambda,u)    p = size(B,2);    beta =zeros(1,p);    for i=1:p        beta(i) = norm(B(:,i),2);    end    c = y;    % sphere center q    rou = zeros(1,p);    for i=1:p        rou(i) = c'*B(:,i);    end    lambda_max = max(abs(rou));    theta_f = lambda*y*min(u)/lambda_max;    [~,indexi] = max( (abs(rou)-lambda*u')./beta );    global n1;    n1 = B(:,indexi)/beta(indexi)*sign(rou(indexi));    h1 = lambda*u(indexi)/beta(indexi);    % sphere radius    global r;    r = norm(theta_f-c,2);    a = n1'*c - h1;    sigma = zeros(1,p);    t = zeros(1,p);    for i=1:p        sigma(i) = n1'*B(:,i);        t(i) = rou(i)-a*sigma(i);    end    list = (abs(t)-1)./beta;    list_order = sort(list);    indexj = find(list==list_order(end));    if indexj==indexi        indexj = find(list==list_order(end-1));    end    global n2;    n2 = B(:,indexj)/beta(indexj)*sign(rou(indexj));    % if size(indexj)>1    h2 = lambda*u(indexj)/beta(indexj);    % phi1,phi2    global phi1;    phi1 = (n1'*c - h1)/r;    global phi2;    phi2 = (n2'*c - h2)/r;    % check phi1 and phi2    if(acos(phi1)+acos(phi2)<acos(n1'*n2))        fprintf('Screening is broken!');    end%     fprintf('%f\n',acos(phi1)+acos(phi2)-acos(n1'*n2));    % Vl & Vu    Vl = zeros(1,p);    Vu = zeros(1,p);    tau = zeros(1,p);    vec = zeros(1,p);    for i=1:p        tau(i) = n2' * B(:,i);        Vu(i) = lambda*u(i) - M2( sigma(i),tau(i),beta(i) );        Vl(i) = M2( -sigma(i),-tau(i),beta(i) ) - lambda*u(i);        if (Vl(i) < rou(i) && Vu(i) > rou(i))            vec(i) = 1;        else            vec(i) = 0;        end    end    end